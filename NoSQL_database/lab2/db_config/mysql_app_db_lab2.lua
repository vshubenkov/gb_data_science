---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by user.
--- DateTime: 2019-04-30 14:31
---

local M = {}

M.start = function(self)
    box.once("bootstrap.0.1", function()
        --users--####################
        if box.space.users then
            box.space.users:drop()
        end
        s = box.schema.space.create('users')
        s:format({
            {name = 'id', type = 'unsigned', is_nullable=false},
            {name = 'firstname', type = 'string', is_nullable=false},
            {name = 'lastname', type = 'string', is_nullable=false},
            {name = 'email', type = 'string', is_nullable=false},
            {name = 'created_at', type = 'string', is_nullable=false},
            {name = 'updated_at', type = 'string', is_nullable=false}
        })
        if box.sequence.S_users then
            box.sequence.S_users:drop()
        end
        box.schema.sequence.create('S_users',{min=1, start=1})
        s:create_index('users_primary_indx', {type = 'hash', parts = {'id'}})
        s:create_index('users_firs_last_indx', {type = 'tree', unique = false, parts = {'firstname','lastname'}})
        s:create_index('users_email_firs_last_indx', {type = 'tree', parts = {'email'}})

        --profiles--##################
        if box.space.profiles then
            box.space.profiles:drop()
        end
        s = box.schema.space.create('profiles')
        s:format({
            {name = 'user_id', type = 'unsigned', is_nullable=false},
            {name = 'sex', type = 'string', is_nullable=false},
            {name = 'hometown', type = 'string', is_nullable=false},
            {name = 'birthday', type = 'string', is_nullable=false},
            {name = 'photo_id', type = 'string', is_nullable=false}
        })
        s:create_index('profiles_primary_indx', {type = 'hash', parts = {'user_id'}})

        --friendship--##################
        if box.space.friendship then
            box.space.friendship:drop()
        end
        s = box.schema.space.create('friendship')
        s:format({
            {name = 'user_id', type = 'unsigned', is_nullable=false},
            {name = 'friend_id', type = 'unsigned', is_nullable=false},
            {name = 'status', type = 'string', is_nullable=false},
            {name = 'requested_at', type = 'string', is_nullable=false},
            {name = 'confirmed_at', type = 'string', is_nullable=false}
        })

        s:create_index('friendship_primary_indx', {type = 'tree', unique = true, parts = {'user_id','friend_id'}})
        s:create_index('friendship_primary_indx_user_id', {type = 'tree', unique = false, parts = {'user_id'}})
        s:create_index('friendship_primary_indx_friend_id', {type = 'tree', unique = false, parts = {'friend_id'}})

        box.schema.user.grant('guest','read,write,execute', 'universe')
        log.info('bootstrap.0.1')
        if box.space.messages then
            box.space.messages:drop()
        end
        s = box.schema.space.create('messages')
        s:format({
            {name = 'id', type = 'unsigned', is_nullable=false},
            {name = 'from_user_id', type = 'unsigned', is_nullable=false},
            {name = 'to_user_id', type = 'unsigned', is_nullable=false},
            {name = 'body', type = 'string', is_nullable=false},
            {name = 'delivered', type = 'boolean', is_nullable=false},
            {name = 'created_at', type = 'string', is_nullable=false}
        })
        s:create_index('messages_primary_indx', {type = 'tree', unique = true, parts = {'id'}})
        s:create_index('messages_secondary_indx', {type = 'tree', unique = false, parts = {'from_user_id','to_user_id'}})
        s:create_index('messages_secondary_delivered', {type = 'tree', unique = false, parts = {'delivered'}})
        s:create_index('messages_secondary_indx_from_user_id', {type = 'tree', unique = false, parts = {'from_user_id'}})
        s:create_index('messages_secondary_indx_to_user_id', {type = 'tree', unique = false, parts = {'to_user_id'}})
        log.info('bootstrap.0.2')
    end)
    box.once("bootstrap.0.2", function()
        if box.sequence.S_messages then
            box.sequence.S_messages:drop()
        end
        box.schema.sequence.create('S_messages',{min=1, start=1})
    end)
end

function insert_obj(obj_tab_name, obj)
    local temp = {}
    if obj_tab_name == 'users' then
        log.info(obj)
        box.space.users:insert{box.sequence.S_users:next(),
                               obj['firstname'],
                               obj['lastname'],
                               obj['email'],
                               obj['created_at'],
                               obj['updated_at']}
    end
    if obj_tab_name == 'profiles' then
        log.info(obj)
        box.space.profiles:insert{ obj['user_id'],
                                   obj['sex'],
                                   obj['hometown'],
                                   obj['birthday'],
                                   obj['photo_id']}
    end
    if obj_tab_name == 'friendship' then
        log.info(obj)
        box.space.friendship:insert{ obj['user_id'],
                                     obj['friend_id'],
                                     obj['status'],
                                     obj['requested_at'],
                                     obj['confirmed_at']}
    end
    if obj_tab_name == 'messages' then
        log.info(obj)
        temp = box.space.messages:insert{   box.sequence.S_messages:next(),
                                     obj['from_user_id'],
                                     obj['to_user_id'],
                                     obj['body'],
                                     obj['delivered'],
                                     obj['created_at']}
    end

    if temp then
        return 'Success add new data table='..obj_tab_name
    else
        return nil
    end

end

function select_users()
        local temp = box.space.users:select{}
        log.info('Success select data table catalogs')
    return temp
end

function func_get_user_by_email(email)
    local temp_u = {}
    local temp = box.space.users.index[2]:select{email}
    if next(temp) ~= nil then
        temp_u['Users'] = temp[1]
        temp = box.space.profiles.index.profiles_primary_indx:select{temp_u['Users'][1]}
        if next(temp) ~= nil then
            temp_u['Profiles'] = temp[1]
            return temp_u -- return user with profile
        else
            return temp_u -- return just user
        end
    else
        return nil -- no user
    end
end

function func_get_user_by_email_user_id(email, user_id)
    local parameter
    local index
    if email then
        parameter = email
        index = 2
    else
        parameter = user_id
        index = 0
    end
    log.info(parameter..index)
    local temp_u = {}
    local temp = box.space.users.index[index]:select{parameter}
    if next(temp) ~= nil then
        temp_u['Users'] = temp[1]
        temp = box.space.profiles.index.profiles_primary_indx:select{temp_u['Users'][1]}
        if next(temp) ~= nil then
            temp_u['Profiles'] = temp[1]
            return temp_u -- return user with profile
        else
            return temp_u -- return just user
        end
    else
        return nil -- no user
    end
end

function func_get_friend_from_friendship(my_user_id)
    local friends = {}
    local temp_u = {}
    local temp_friends_out = box.space.friendship.index.friendship_primary_indx_user_id:select{my_user_id}
    for key, value in pairs(temp_friends_out) do
        friends = {}
        friends['Friend_id'] = value[2]
        friends['Status'] = value[3]
        friends['Requsted_time'] = value[4]
        friends['Updated'] = value[5]
        friends['Requested_by'] = value[1]
        table.insert(temp_u, friends)
    end
    local temp_friends_in = box.space.friendship.index.friendship_primary_indx_friend_id:select{my_user_id}
    for key, value in pairs(temp_friends_in) do
        friends = {}
        friends['Friend_id'] = value[1]
        friends['Status'] = value[3]
        friends['Requsted_time'] = value[4]
        friends['Updated'] = value[5]
        friends['Requested_by'] = value[1]
        table.insert(temp_u, friends)
    end
    if next(temp_u) ~= nil then
        return temp_u
    else
        return nil
    end
end

function func_status_friend_from_friendship(my_user_id, status)
    local friends = {}
    local temp_u = {}
    local temp_friends_in = box.space.friendship.index.friendship_primary_indx_friend_id:select{my_user_id}
    for key, value in pairs(temp_friends_in) do
        if value[3] == status then
            friends = {}
            friends['Friend_id'] = value[1]
            friends['Status'] = value[3]
            friends['Requsted_time'] = value[4]
            friends['Updated'] = value[5]
            friends['Requested_by'] = value[1]
            table.insert(temp_u, friends)
        end
    end
    if status == 'Accepted' then
        local temp_friends_out = box.space.friendship.index.friendship_primary_indx_user_id:select{my_user_id}
        for key, value in pairs(temp_friends_out) do
            if value[3] == status then
                friends = {}
                friends['Friend_id'] = value[2]
                friends['Status'] = value[3]
                friends['Requsted_time'] = value[4]
                friends['Updated'] = value[5]
                friends['Requested_by'] = value[1]
                table.insert(temp_u, friends)
            end
        end
    end
    if next(temp_u) ~= nil then
        return temp_u
    else
        return nil
    end
end

function func_accept_aprove_friend_from_friendship(f_user_id, my_user_id)
    local temp = box.space.friendship.index.friendship_primary_indx:update({f_user_id, my_user_id}, {{'=', 3, 'Accepted'}})
    if temp then
        box.space.friendship.index.friendship_primary_indx:update({f_user_id, my_user_id}, {{'=', 5, os.date()}})
        return "Friend "..f_user_id.." accepted"
    else
        return nil
    end
end

function func_check_friend_in_friendship(f_user_id,my_user_id)
    local temp = box.space.friendship.index.friendship_primary_indx:select({my_user_id,f_user_id})
    if next(temp) then
        return temp
    else
        temp = box.space.friendship.index.friendship_primary_indx:select({f_user_id,my_user_id})
        if next(temp) then
            return temp
        else
            return nil
        end
    end
end

function func_search_possible_friends_users(var_user_id, pattern)
    local temp_u = {}
    for k, v in pairs(box.space.users.index.users_email_firs_last_indx:select()) do
        if  string.find(v[4], pattern) then
            local var_check_friend = func_check_friend_in_friendship(var_user_id,v[1])
            if not var_check_friend and var_user_id ~= v[1] then
                table.insert(temp_u, v)
            end
        end
    end
    if next(temp_u) then
        return temp_u
    else
        return nil
    end
end


function func_add_friends_users(f_user_id,my_user_id)
    if f_user_id == my_user_id then
        return nil
    end
    local turple = {}
    local var_user = box.space.users.index.users_primary_indx:select(f_user_id)
    log.info(var_user[1])
    if var_user[1] then
        local var_check_f = func_check_friend_in_friendship(f_user_id,my_user_id)
        if var_check_f then
            return "У вас уже есть друг "..f_user_id
        else
            turple['user_id'] = my_user_id
            turple['friend_id'] = f_user_id
            turple['status'] = 'initial'
            turple['requested_at'] =  os.date()
            turple['confirmed_at'] = '00000000'
            log.info('insert')
            return insert_obj("friendship", turple)
        end
    else
        return nil
    end
end


function func_write_message(from_user_id, to_user_id, body)
    local turple = {}
    local temp = func_check_friend_in_friendship(from_user_id,to_user_id)
    if next(temp) then
        if temp[1][3] == 'Accepted' then
            turple['from_user_id'] = from_user_id
            turple['to_user_id'] = to_user_id
            turple['body'] = body
            turple['delivered'] =  false
            turple['created_at'] = os.date()
            log.info('insert_message')
            return insert_obj("messages", turple)
        else
            return nil
        end
    else
        return nil
    end
end

function func_read_new_message(my_user)
    local turple = {}
    local temp = box.space.messages.index.messages_secondary_indx_to_user_id:select(my_user)
    if next(temp) then
        for key, value in pairs(temp) do
            if not value[5] then
                table.insert(turple, value)
                box.space.messages.index.messages_primary_indx:update(value[1], {{'=', 5, true}})
            end
        end
    end
    if next(turple) then
        return turple
    else
        return nil
    end
end

function func_check_write_message(my_user_id, f_user_id)
    local status = false
    local temp = box.space.friendship.index.friendship_primary_indx:select({my_user_id, f_user_id})
    if next(temp) then
        if temp[1][3] == 'Accepted' then
            status = true
        end
    end
    local temp = box.space.friendship.index.friendship_primary_indx:select({f_user_id, my_user_id})
    if next(temp) then
        if temp[1][3] == 'Accepted' then
            status = true
        end
    end
    if status then
        return "ok"
    else
        return nil
    end
end

function func_read_all_message(my_user)
    local turple = {}
    local temp = box.space.messages.index.messages_secondary_indx_to_user_id:select(my_user)
    if next(temp) then
        for key, value in pairs(temp) do
                table.insert(turple, value)
        end
    end
    if next(turple) then
        return turple
    else
        return nil
    end
end

return M
